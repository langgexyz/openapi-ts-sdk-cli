/**
 * ä»£ç ç”Ÿæˆå™¨ - åŸºäºè§£æçš„ OpenAPI æ•°æ®ç”Ÿæˆ TypeScript ä»£ç 
 */

import { pascalCase, camelCase } from 'change-case';
import { createHash } from 'crypto';
import { APIGroup, TypeDefinition, APIOperation, TypeProperty } from './openapi-parser';

export interface GeneratorOptions {
  className?: string;
  packageName?: string;
  projectName?: string;
  sourceContent?: string; // æºæ–‡ä»¶å†…å®¹ï¼Œç”¨äºç”Ÿæˆhash
}

export class CodeGenerator {
  constructor() {
    // åˆå§‹åŒ–ä»£ç ç”Ÿæˆå™¨
  }

  /**
   * ç”Ÿæˆ TypeScript SDK ä»£ç 
   *
   * @param apis - è§£æåçš„ API ç»„æ•°ç»„
   * @param options - ç”Ÿæˆé€‰é¡¹é…ç½®
   * @returns Map<æ–‡ä»¶å, æ–‡ä»¶å†…å®¹> - ç”Ÿæˆçš„å¤šä¸ª TypeScript æ–‡ä»¶
   *
   * ç”Ÿæˆç­–ç•¥:
   * 1. ç”Ÿæˆ client.ts - åŒ…å«å…±äº«çš„åŸºç¡€ç±»å‹å’Œå®¢æˆ·ç«¯åŸºç±»
   * 2. æŒ‰ Controller åˆ†ç»„ç”Ÿæˆç‹¬ç«‹çš„ API æ–‡ä»¶
   * 3. æ¯ä¸ª Controller æ–‡ä»¶åŒ…å«å¯¹åº”çš„ç±»å‹å®šä¹‰å’Œ API æ–¹æ³•
   */
  generate(apis: APIGroup[], options: GeneratorOptions): Map<string, string> {
    const files = new Map<string, string>();

    // ç”Ÿæˆå…±äº«çš„åŸºç¡€ç±»å‹å’ŒåŸºç±» (client.ts)
    const clientContent = this.generateSharedApiTypes();
    files.set('client.ts', clientContent);

    // æŒ‰ Controller åç§°åˆ†ç»„ï¼Œä¸ºæ¯ä¸ª Controller ç”Ÿæˆç‹¬ç«‹çš„ API æ–‡ä»¶
    const controllerGroups = this.groupByController(apis);
    
    for (const [controllerName, controllerApis] of controllerGroups) {
      const apiContent = this.generateControllerApi(controllerName, controllerApis, apis, options);
      files.set(`${controllerName.toLowerCase()}.ts`, apiContent); // å»æ‰.apiåç¼€
    }
    
    // ç”Ÿæˆä¸»å…¥å£æ–‡ä»¶
    const indexContent = this.generateIndexFile(Array.from(controllerGroups.keys()));
    files.set('index.ts', indexContent);

    return files;
  }



  /**
   * å°† API æ“ä½œæŒ‰ Controller åç§°åˆ†ç»„
   *
   * @param apis - API ç»„æ•°ç»„
   * @returns Map<Controlleråç§°, APIGroup[]> - æŒ‰ Controller åˆ†ç»„çš„ç»“æœ
   *
   * åˆ†ç»„é€»è¾‘:
   * 1. éå†æ‰€æœ‰ API ç»„ä¸­çš„æ“ä½œ
   * 2. ä»æ“ä½œåç§°ä¸­æå– Controller åç§° (ä¾‹: UserController_getUser -> UserController)
   * 3. å°†ç›¸åŒ Controller çš„æ“ä½œå½’ç±»åˆ°åŒä¸€ç»„
   */
  private groupByController(apis: APIGroup[]): Map<string, APIGroup[]> {
    const groups = new Map<string, APIGroup[]>();

    for (const api of apis) {
      // å¤„ç†æœ‰æ“ä½œçš„APIç»„
      if (api.operations.length > 0) {
        // éå† API ç»„ä¸­çš„æ‰€æœ‰æ“ä½œï¼Œæå– Controller åç§°
        for (const operation of api.operations) {
          const controllerName = this.extractControllerName(operation.name);
          if (!groups.has(controllerName)) {
            groups.set(controllerName, []);
          }
          
          // ä¸ºæ¯ä¸ª Controller åˆ›å»ºç‹¬ç«‹çš„ API å¯¹è±¡
          const controllerGroup = groups.get(controllerName);
          if (controllerGroup) {
            let controllerApi = controllerGroup.find(a => a.className === controllerName);
            if (!controllerApi) {
              controllerApi = {
                className: controllerName,
                operations: [],
                types: []  // å°†åœ¨åé¢æ”¶é›†ç›¸å…³ç±»å‹
              };
              controllerGroup.push(controllerApi);
            }
            
            controllerApi.operations.push(operation);
          }
        }
      } else {
        // å¤„ç†æ²¡æœ‰æ“ä½œçš„APIç»„ï¼ˆå¦‚GlobalTypesï¼‰ï¼Œä¹Ÿè¦ç”Ÿæˆæ–‡ä»¶
        const controllerName = api.className;
        if (!groups.has(controllerName)) {
          groups.set(controllerName, []);
        }
        
        const controllerGroup = groups.get(controllerName);
        if (controllerGroup) {
          let controllerApi = controllerGroup.find(a => a.className === controllerName);
          if (!controllerApi) {
            controllerApi = {
              className: controllerName,
              operations: [], // æ²¡æœ‰æ“ä½œ
              types: [] // å°†åœ¨åé¢æ”¶é›†ç›¸å…³ç±»å‹
            };
            controllerGroup.push(controllerApi);
          }
        }
      }
    }
    
    // é‡æ–°åˆ†é…æ‰€æœ‰APIç»„çš„ç±»å‹å®šä¹‰ç»™ç›¸åº”çš„ Controller
    for (const api of apis) {
      for (const type of api.types) {
        // æ ¹æ®ç±»å‹åç§°æ‰¾åˆ°å¯¹åº”çš„ Controller
        let assignedController: string | null = null;
        for (const [controllerName] of groups) {
          if (type.name.toLowerCase().includes(controllerName.toLowerCase())) {
            assignedController = controllerName;
            break;
          }
        }
        
        // åªåˆ†é…ç±»å‹ç»™å·²å­˜åœ¨çš„Controllerï¼Œé¿å…åˆ›å»ºä¸å¿…è¦çš„Common Controller
        if (assignedController) {
          const controllerApis = groups.get(assignedController);
          if (controllerApis && controllerApis[0]) {
            controllerApis[0].types.push(type);
          }
        }
        // å¦‚æœæ‰¾ä¸åˆ°åŒ¹é…çš„Controllerï¼Œè·³è¿‡è¿™ä¸ªç±»å‹
        // å®ƒå¯èƒ½å·²ç»è¢«å…¶ä»–Controlleré€šè¿‡å¼•ç”¨åŒ…å«äº†
      }
    }
    
    return groups;
  }

  /**
   * ä»æ“ä½œåç§°ä¸­æå– Controller åç§°
   *
   * @param operationName - æ“ä½œåç§° (ä¾‹: "UserController_getUser", "user_getProfile")
   * @returns æ ‡å‡†åŒ–çš„ Controller åç§° (ä¾‹: "User")
   *
   * æå–è§„åˆ™:
   * 1. æ”¯æŒæ ¼å¼: "ControllerName_methodName" æˆ– "ControllerNameController_methodName"
   * 2. è‡ªåŠ¨å»é™¤ "Controller" åç¼€
   * 3. è½¬æ¢ä¸º PascalCase æ ¼å¼
   * 4. æ¸…ç†å¯èƒ½çš„æ—¥æœŸä¿¡æ¯
   */
  private extractControllerName(operationName: string): string {
    // éªŒè¯æ“ä½œåç§°æ ¼å¼å¹¶æå– Controller åç§°
    if (!operationName) {
      throw new Error(`operationName is empty, unable to extract Controller name`);
    }
    
    const match = operationName.match(/^([a-zA-Z]+?)(?:controller)?[_]([a-zA-Z]+)/i);
    if (!match) {
      throw new Error(`operationName "${operationName}" format is incorrect. Expected format: "controllerName_methodName" or "controllerNameController_methodName"`);
    }
    
    // è½¬æ¢ä¸ºé©¼å³°å‘½åï¼Œå»æ‰Controlleråç¼€
    const controllerName = match[1].replace(/controller$/i, ''); // å»æ‰controlleråç¼€
    return this.toPascalCase(controllerName).replace(/\d{8}/, ''); // ç§»é™¤å¯èƒ½çš„æ—¥æœŸä¿¡æ¯
  }
  
  /**
   * è½¬æ¢ä¸ºPascalCaseå‘½å - ç›´æ¥ä½¿ç”¨change-caseåº“
   */
  private toPascalCase(str: string): string {
    return pascalCase(str);
  }

  /**
   * ç”Ÿæˆå…±äº«çš„åŸºç¡€ç±»å‹å’ŒåŸºç±»
   */
  private generateSharedApiTypes(): string {
    return `// å…±äº«ç±»å‹å®šä¹‰å’ŒåŸºç¡€ API å®¢æˆ·ç«¯

import { HttpBuilder, HttpMethod } from 'openapi-ts-sdk';
import { plainToClass, instanceToPlain, Type, Expose, Exclude } from 'class-transformer';

// API é…ç½®æ¥å£
export interface APIConfig {
  uri: string;           // è¯·æ±‚ URIï¼ˆæ¯ä¸ªæ–¹æ³•éƒ½æœ‰é»˜è®¤å€¼ï¼Œå¯é€šè¿‡ withUri è¦†ç›–ï¼‰
  headers: Record<string, string>;  // è¯·æ±‚ headersï¼ˆé»˜è®¤åŒ…å« Content-Typeï¼‰
}

// å‡½æ•°å¼é€‰é¡¹ç±»å‹
export type APIOption = (config: APIConfig) => void;

// é€‰é¡¹æ„é€ å‡½æ•°
export const withUri = (uri: string): APIOption => (config) => {
  config.uri = uri;
};

export const withHeaders = (headers: Record<string, string>): APIOption => (config) => {
  config.headers = { ...config.headers, ...headers };
};

export const withHeader = (key: string, value: string): APIOption => (config) => {
  config.headers = { ...config.headers, [key]: value };
};

// ç»„åˆé€‰é¡¹
export const combineOptions = (...options: APIOption[]): APIOption => (config) => {
  options.forEach(option => option(config));
};

/**
 * åŸºç¡€ API å®¢æˆ·ç«¯æŠ½è±¡ç±»
 * 
 * ğŸ¯ AI åŠ©æ‰‹ä½¿ç”¨æŒ‡å— - åŸºäº openapi-ts-sdk-cli å®é™…å®ç°:
 * å½“ä½ é˜…è¯»åˆ°è¿™ä¸ªç±»æ—¶ï¼Œè¯·éµå¾ªä»¥ä¸‹ä» CLI æºç æç‚¼çš„çœŸå®ç”Ÿæˆè§„èŒƒï¼š
 * 
 * ğŸ“‹ ä¸¥æ ¼ç±»å‹çº¦æŸ (åŸºäº Record<string, any>):
 * â€¢ executeRequest æ–¹æ³•å¼ºåˆ¶è¦æ±‚å…·ä½“å¯¹è±¡ç±»å‹
 * â€¢ âŒ ç¼–è¯‘æ—¶é˜»æ­¢: any, unknown, string, number, boolean ç­‰
 * â€¢ âœ… è¿è¡Œæ—¶è¦æ±‚: å®ç°äº† validate() æ–¹æ³•çš„ Request ç±»
 * â€¢ ğŸ¯ åŒé‡ä¿éšœ: ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥ + è¿è¡Œæ—¶æ•°æ®éªŒè¯
 * 
 * ğŸ—ï¸ æ–‡ä»¶ç»“æ„ç”Ÿæˆè§„èŒƒ:
 * â€¢ client.ts: å…±äº«åŸºç¡€ç±»å‹å’Œ APIClient æŠ½è±¡ç±»
 * â€¢ {controller}.ts: æŒ‰ Controller åˆ†ç»„çš„ API å®ç° (å¦‚ user.ts, order.ts)
 * â€¢ index.ts: ä¸»å…¥å£æ–‡ä»¶ï¼Œå¯¼å‡ºæ‰€æœ‰æ¨¡å—å’Œç»Ÿä¸€å®¢æˆ·ç«¯
 * â€¢ æ–‡ä»¶åè§„åˆ™: controllerName.toLowerCase() + ".ts"
 * 
 * ğŸ¯ Controller åç§°æå–è§„åˆ™:
 * â€¢ è¾“å…¥æ ¼å¼: "UserController_getProfile" æˆ– "user_getProfile"
 * â€¢ æ­£åˆ™åŒ¹é…: /^([a-zA-Z]+?)(?:controller)?[_]([a-zA-Z]+)/i
 * â€¢ å¤„ç†é€»è¾‘: æå–å‰ç¼€ï¼Œå»é™¤ "Controller" åç¼€ï¼Œè½¬ä¸º PascalCase
 * â€¢ ç¤ºä¾‹è½¬æ¢: "UserController_getProfile" â†’ "User"
 * 
 * ğŸ”§ æ–¹æ³•åç”Ÿæˆç®—æ³• (generateMethodNameFromPath):
 * 
 * 1ï¸âƒ£ è·¯å¾„é¢„å¤„ç†:
 *    â€¢ ç§»é™¤è·¯å¾„å‚æ•°: "/users/{id}/profile" â†’ "/users//profile"
 *    â€¢ è¿‡æ»¤APIå‰ç¼€: å¿½ç•¥ "api", "v1", "v2" ç­‰æ®µ
 *    â€¢ åˆ†å‰²è·¯å¾„æ®µ: ["/users", "/profile"] â†’ ["users", "profile"]
 * 
 * 2ï¸âƒ£ å•è¯åˆ†è§£:
 *    â€¢ é©¼å³°æ‹†åˆ†: "systemId" â†’ ["system", "Id"]
 *    â€¢ ç¬¦å·åˆ†å‰²: "user-profile" â†’ ["user", "profile"]
 *    â€¢ ä¸‹åˆ’çº¿åˆ†å‰²: "user_profile" â†’ ["user", "profile"]
 * 
 * 3ï¸âƒ£ HTTP æ–¹æ³•æ˜ å°„:
 *    â€¢ GET â†’ "get"        | POST â†’ "create"
 *    â€¢ PUT â†’ "update"     | DELETE â†’ "delete"
 *    â€¢ PATCH â†’ "patch"    | å…¶ä»– â†’ åŸå€¼
 * 
 * 4ï¸âƒ£ æœ€ç»ˆç»„åˆ:
 *    â€¢ åŸºç¡€: methodPrefix + pathWords (camelCase)
 *    â€¢ å¸¦å‚æ•°: æ·»åŠ  "By" + å‚æ•°å (PascalCase)
 *    â€¢ ç¤ºä¾‹: GET /users/{id} â†’ getUserById(id: string)
 * 
 * ğŸ“¦ Request/Response ç±»å‹å‘½å:
 * â€¢ Request: {MethodName}Request (å¦‚ GetUserByIdRequest)
 * â€¢ Response: {MethodName}Response (å¦‚ GetUserByIdResponse)
 * â€¢ æ§åˆ¶å™¨ç®€åŒ–: ç§»é™¤æ§åˆ¶å™¨å‰ç¼€ï¼Œé¿å…é‡å¤
 * â€¢ è½¬æ¢è§„åˆ™: ä½¿ç”¨ pascalCase åº“ç¡®ä¿å‘½åä¸€è‡´æ€§
 * 
 * ğŸ¨ Namespace ç»“æ„æ¨¡å¼:
 * export namespace User {
 *   // ç®€åŒ–çš„ç±»å‹å®šä¹‰ (ç§»é™¤ User å‰ç¼€)
 *   export class GetProfileRequest { ... }
 *   export class ProfileResponse { ... }
 *   
 *   // API å®¢æˆ·ç«¯å®ç°
 *   export class Client extends APIClient {
 *     async getProfile(request: GetProfileRequest): Promise<ProfileResponse> {
 *       return this.executeRequest<GetProfileRequest, ProfileResponse>(...);
 *     }
 *   }
 * }
 * 
 * ğŸ”„ å®é™…ç”Ÿæˆç¤ºä¾‹ (åŸºäºçœŸå®ç®—æ³•):
 * 
 * OpenAPI Operation: UserController_getUserProfile
 * Path: GET /api/v1/users/{userId}/profile
 * 
 * ç®—æ³•å¤„ç†è¿‡ç¨‹:
 * 1. æå–æ§åˆ¶å™¨: "UserController_getUserProfile" â†’ "User"
 * 2. æ¸…ç†è·¯å¾„: "/api/v1/users/{userId}/profile" â†’ "/users//profile"
 * 3. åˆ†è§£å•è¯: ["users", "profile"]
 * 4. æ–¹æ³•å‰ç¼€: "get" (å› ä¸ºæ˜¯ GET)
 * 5. è·¯å¾„å‚æ•°: ["userId"]
 * 6. æœ€ç»ˆæ–¹æ³•å: "getUserProfileByUserId"
 * 7. Requestç±»å‹: "GetUserProfileByUserIdRequest"
 * 8. Responseç±»å‹: "GetUserProfileByUserIdResponse"
 * 
 * ğŸ›¡ï¸ æ•°æ®éªŒè¯é›†æˆ:
 * â€¢ æ‰€æœ‰ Request ç±»è‡ªåŠ¨åŒ…å« validate() æ–¹æ³•
 * â€¢ ä½¿ç”¨ class-validator è£…é¥°å™¨è¿›è¡Œçº¦æŸå®šä¹‰
 * â€¢ executeRequest è‡ªåŠ¨è°ƒç”¨ request.validate()
 * â€¢ å“åº”æ•°æ®é€šè¿‡ class-transformer ååºåˆ—åŒ–
 * 
 * ğŸ“š æ ¸å¿ƒä¾èµ–å’Œä½œç”¨:
 * â€¢ change-case: pascalCase/camelCase å‘½åè½¬æ¢
 * â€¢ class-validator: @IsString, @IsNumber ç­‰éªŒè¯è£…é¥°å™¨
 * â€¢ class-transformer: plainToClass, instanceToPlain åºåˆ—åŒ–
 * â€¢ reflect-metadata: è£…é¥°å™¨å…ƒæ•°æ®è¿è¡Œæ—¶æ”¯æŒ
 * â€¢ openapi-ts-sdk: HttpBuilder, HttpMethod æ ¸å¿ƒHTTPåŠŸèƒ½
 * 
 * ğŸ”„ ç”Ÿæˆå™¨ä¿¡æ¯:
 * â€¢ å·¥å…·: openapi-ts-sdk-cli CodeGenerator
 * â€¢ ç®—æ³•ç‰ˆæœ¬: å¸¦ä¸¥æ ¼ç±»å‹çº¦æŸå’Œæ™ºèƒ½å‘½åçš„å¢å¼ºç‰ˆ
 * â€¢ å“ˆå¸Œè¿½è¸ª: ä½¿ç”¨æºæ–‡ä»¶ MD5 ç¡®ä¿ç”Ÿæˆä¸€è‡´æ€§
 * â€¢ æ›´æ–°ç­–ç•¥: é‡æ–°ç”Ÿæˆè¦†ç›–ï¼Œä¸æ”¯æŒæ‰‹åŠ¨ä¿®æ”¹ä¿ç•™
 */
export abstract class APIClient {export abstract class APIClient {
  protected httpBuilder: HttpBuilder;

  constructor(httpBuilder: HttpBuilder) {
    this.httpBuilder = httpBuilder;
  }

  /**
   * é€šç”¨å‚æ•°éªŒè¯æ–¹æ³•
   * @protected
   */
  protected validateRequest<T = unknown>(request: T): void {
    if (!request) {
      throw new Error('å‚æ•° request æ˜¯å¿…éœ€çš„');
    }
    
    if (typeof request !== 'object') {
      throw new Error('å‚æ•° request å¿…é¡»æ˜¯å¯¹è±¡ç±»å‹');
    }
  }

  /**
   * é€šç”¨è¯·æ±‚å¤„ç†æ–¹æ³• - å¤„ç† HTTP è¯·æ±‚å’Œå“åº”çš„åºåˆ—åŒ–/ååºåˆ—åŒ–
   * 
   * @protected
   * @template TRequest - è¯·æ±‚ç±»å‹ï¼Œå¿…é¡»æ˜¯æ˜ç¡®å®šä¹‰çš„å¯¹è±¡ç±»å‹ï¼ˆclass æˆ– interfaceï¼‰
   *                     âŒ ç¦æ­¢ä½¿ç”¨ï¼šanyã€unknownã€stringã€numberã€boolean ç­‰åŸºç¡€ç±»å‹
   *                     âœ… æ¨èä½¿ç”¨ï¼šå…·ä½“çš„ Request ç±»ï¼ˆå¦‚ LoginRequestã€UserCreateRequestï¼‰
   * @template TResponse - å“åº”ç±»å‹ï¼Œå¿…é¡»æ˜¯æ˜ç¡®å®šä¹‰çš„å¯¹è±¡ç±»å‹ï¼ˆclass æˆ– interfaceï¼‰
   *                      âŒ ç¦æ­¢ä½¿ç”¨ï¼šanyã€unknownã€stringã€numberã€boolean ç­‰åŸºç¡€ç±»å‹
   *                      âœ… æ¨èä½¿ç”¨ï¼šå…·ä½“çš„ Response ç±»ï¼ˆå¦‚ LoginResponseã€UserResponseï¼‰
   * 
   * @example
   * // âœ… æ­£ç¡®ç”¨æ³•ï¼š
   * await this.executeRequest<LoginRequest, LoginResponse>(
   *   HttpMethod.POST, "/login", request, LoginResponse, options
   * );
   * 
   * // âŒ é”™è¯¯ç”¨æ³•ï¼ˆä¼šäº§ç”Ÿç¼–è¯‘é”™è¯¯ï¼‰ï¼š
   * await this.executeRequest<any, any>(...)           // any è¢«ç¦æ­¢
   * await this.executeRequest<string, object>(...)     // åŸºç¡€ç±»å‹è¢«ç¦æ­¢
   * await this.executeRequest<unknown, unknown>(...)   // unknown è¢«ç¦æ­¢
   */
  protected async executeRequest<
    TRequest extends Record<string, any> = Record<string, never>,
    TResponse extends Record<string, any> = Record<string, never>
  >(    method: HttpMethod,
    path: string,
    request: TRequest,
    responseType: {new(...args:any[]): TResponse},
    options: APIOption[] = []
  ): Promise<TResponse> {
    
    // åˆ›å»ºé»˜è®¤é…ç½®
    const config: APIConfig = {
      uri: path,
      headers: {
        'Content-Type': 'application/json'
      }
    };
    
    // åº”ç”¨æ‰€æœ‰é€‰é¡¹
    options.forEach(option => option(config));
    
    // æ„å»º HTTP è¯·æ±‚
    const httpBuilder = this.httpBuilder
      .setUri(config.uri)
      .setMethod(method);
    
    // æ·»åŠ  headers
    Object.entries(config.headers).forEach(([key, value]) => {
      httpBuilder.addHeader(key, value);
    });
    
    // åºåˆ—åŒ–è¯·æ±‚ä½“ï¼ˆå¦‚æœæœ‰ï¼‰
    if (request) {
      const requestJson = JSON.stringify(instanceToPlain(request));
      httpBuilder.setContent(requestJson);
    }
    
    const http = httpBuilder.build();
    const [response, error] = await http.send();
    
    if (error) {
      throw error;
    }
    
    if (response === "") {
      throw new Error("response is empty");
    }
    
    // ä½¿ç”¨class-transformerè¿›è¡Œååºåˆ—åŒ–
    const responseData = JSON.parse(response);
    const result = plainToClass(responseType, responseData);
    return result;
  }
}
`;
  }

  /**
   * ç”Ÿæˆå•ä¸ª Controller çš„ API ç±»
   */
  private generateControllerApi(controllerName: string, apis: APIGroup[], allApis: APIGroup[], options: GeneratorOptions): string {
    const packageName = options.packageName || 'openapi-ts-sdk';
    const className = controllerName; // ç›´æ¥ä½¿ç”¨controllerNameï¼Œä¸æ‹¼æ¥Apiåç¼€
    
    // ç”Ÿæˆæºæ–‡ä»¶å†…å®¹çš„hash
    const sourceHash = options.sourceContent ? 
      createHash('md5').update(options.sourceContent).digest('hex').substring(0, 8) : 
      'unknown';
    
    let output = `/**
 * Auto-generated by openapi-ts-sdk-cli. Do not edit manually!
 * 
 * Source hash: ${sourceHash}
 * Generator: openapi-ts-sdk-cli
 * Source: OpenAPI specification
 * 
 * To modify this file:
 * 1. Update the server-side OpenAPI specification
 * 2. Regenerate using openapi-ts-sdk-cli
 * 
 * Direct edits will be overwritten on next generation!
 */

import 'reflect-metadata';
import { HttpMethod } from 'openapi-ts-sdk';
import { APIClient, APIOption, APIConfig } from './client';
import { plainToClass, instanceToPlain, Type, Expose, Exclude } from 'class-transformer';
import { IsString, IsNumber, IsBoolean, IsOptional, IsEmail, Min, Max, MinLength, MaxLength, Matches, validate } from 'class-validator';

export namespace ${className} {`;

    // å…ˆæ”¶é›†æ‰€æœ‰æ“ä½œ
    const allOperations: APIOperation[] = [];
    for (const api of apis) {
      allOperations.push(...api.operations);
    }
    
    // æ”¶é›†è¯¥ Controller ç›¸å…³çš„ç±»å‹å®šä¹‰ï¼ˆå»é‡ï¼‰
    const controllerTypes: Map<string, TypeDefinition> = new Map();
    
    for (const api of apis) {
      // æ”¶é›†ç›¸å…³çš„ç±»å‹å®šä¹‰
      for (const type of api.types) {
        // æ£€æŸ¥ç±»å‹æ˜¯å¦å±äºå½“å‰æ§åˆ¶å™¨  
        // ä½¿ç”¨å…œåº•ç­–ç•¥ï¼šåŒ…å«æ‰€æœ‰Requestå’ŒResponseç±»å‹
        const belongsToController = 
          type.name.toLowerCase().includes(controllerName.toLowerCase()) || 
          type.name === 'Error' || // é€šç”¨é”™è¯¯ç±»å‹
          allOperations.some(op => op.requestType === type.name || op.responseType === type.name) ||
          // å…œåº•ç­–ç•¥ï¼šåŒ…å«æ‰€æœ‰Requestå’ŒResponseç±»å‹åˆ°æ¯ä¸ªæ§åˆ¶å™¨
          type.name.toLowerCase().includes('request') || type.name.toLowerCase().includes('response');
        
        if (belongsToController) {
          // ä½¿ç”¨ Map å»é‡
          controllerTypes.set(type.name, type);
        }
      }
    }
    
    // æ”¶é›†æ‰€æœ‰è¢«å¼•ç”¨çš„ç±»å‹ï¼ˆåŒ…æ‹¬é—´æ¥å¼•ç”¨ï¼‰
    const referencedTypes = new Set<string>();
    const collectReferencedTypes = (type: TypeDefinition) => {
      for (const [_, prop] of Object.entries(type.properties)) {
        // æ£€æŸ¥å±æ€§ç±»å‹æ˜¯å¦å¼•ç”¨äº†å…¶ä»–ç±»å‹
        if (prop.type.includes('[]')) {
          const baseType = prop.type.replace('[]', '');
          if (baseType !== 'string' && baseType !== 'number' && baseType !== 'boolean' && !baseType.startsWith('Record<')) {
            referencedTypes.add(baseType);
          }
        } else if (prop.type !== 'string' && prop.type !== 'number' && prop.type !== 'boolean' && !prop.type.startsWith('Record<')) {
          referencedTypes.add(prop.type);
        }
      }
    };
    
    // æ”¶é›†æ‰€æœ‰å·²å®šä¹‰ç±»å‹çš„å¼•ç”¨
    for (const [_, type] of controllerTypes) {
      collectReferencedTypes(type);
    }
    
    // æ·»åŠ è¢«å¼•ç”¨çš„ç±»å‹å®šä¹‰ - ä»æ‰€æœ‰APIç»„ä¸­æŸ¥æ‰¾
    for (const apiGroup of apis) {
      for (const type of apiGroup.types) {
        if (referencedTypes.has(type.name)) {
          controllerTypes.set(type.name, type);
        }
      }
    }
    
    // å¦‚æœè¿˜æœ‰æœªæ‰¾åˆ°çš„å¼•ç”¨ç±»å‹ï¼Œå°è¯•ä»å…¨å±€ç±»å‹ä¸­æŸ¥æ‰¾
    const allGlobalTypes = new Map<string, TypeDefinition>();
    for (const apiGroup of allApis) {
      for (const type of apiGroup.types) {
        allGlobalTypes.set(type.name, type);
      }
    }
    
    // åªæ·»åŠ è¢«å½“å‰æ§åˆ¶å™¨å¼•ç”¨çš„å…¨å±€ç±»å‹ï¼Œè€Œä¸æ˜¯æ‰€æœ‰å…¨å±€ç±»å‹
    for (const referencedType of referencedTypes) {
      if (!controllerTypes.has(referencedType) && allGlobalTypes.has(referencedType)) {
        controllerTypes.set(referencedType, allGlobalTypes.get(referencedType)!);
      }
    }

    // æ”¶é›†ç®€åŒ–çš„ç±»å‹å®šä¹‰ï¼Œå‡†å¤‡ä½œä¸ºåµŒå¥—ç±»
    const nestedTypes: any[] = [];
    const collectedTypeNames = new Set<string>();
    
    // æ”¶é›†æ˜ç¡®å®šä¹‰çš„ç±»å‹å¹¶åˆ›å»ºç±»å‹åæ˜ å°„
    const typeNameMapping = new Map<string, string>();
    
    if (controllerTypes.size > 0) {
      for (const [_, type] of controllerTypes) {
        // ç®€åŒ–ç±»å‹åç§°ï¼šç§»é™¤æ§åˆ¶å™¨å‰ç¼€
        let simplifiedName = type.name;
        
        // ç§»é™¤æ§åˆ¶å™¨åå‰ç¼€ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        const controllerPrefix = this.toPascalCase(controllerName);
        if (simplifiedName.startsWith(controllerPrefix)) {
          simplifiedName = simplifiedName.substring(controllerPrefix.length);
        }
        
        // ç¡®ä¿æ˜¯PascalCase
        simplifiedName = this.toPascalCase(simplifiedName);
        
        // è®°å½•ç±»å‹åæ˜ å°„
        typeNameMapping.set(type.name, simplifiedName);
        
        const simplifiedType = {
          ...type,
          name: simplifiedName
        };
        nestedTypes.push(simplifiedType);
        collectedTypeNames.add(simplifiedName);
      }
    }
    
    // æ›´æ–°æ‰€æœ‰ç±»å‹ä¸­çš„ç±»å‹å¼•ç”¨
    for (const type of nestedTypes) {
      for (const [propName, prop] of Object.entries(type.properties)) {
        // æ›´æ–°å±æ€§ç±»å‹å¼•ç”¨
        const typedProp = prop as any;
        if (typedProp.type && typedProp.type.includes('[]')) {
          const baseType = typedProp.type.replace('[]', '');
          if (typeNameMapping.has(baseType)) {
            typedProp.type = typeNameMapping.get(baseType)! + '[]';
          }
        } else if (typedProp.type && typeNameMapping.has(typedProp.type)) {
          typedProp.type = typeNameMapping.get(typedProp.type)!;
        }
      }
    }
    
    // æ”¶é›†æ‰€æœ‰æ“ä½œä½¿ç”¨çš„ç±»å‹ï¼Œä¸ºç¼ºå¤±çš„ç±»å‹ç”ŸæˆåŸºç¡€å®šä¹‰
    
    for (const operation of allOperations) {
      // å¤„ç†Responseç±»å‹ - ç»Ÿä¸€ä½¿ç”¨åŸºäºæ–¹æ³•åç”Ÿæˆçš„ç±»å‹å
      const responseTypeName = this.getSimpleName(this.generateDefaultResponseTypeName(operation), controllerName);
      
      if (!collectedTypeNames.has(responseTypeName)) {
        // ç”ŸæˆåŸºç¡€çš„å“åº”ç±»å‹å®šä¹‰
        const basicResponseType: TypeDefinition = {
          name: responseTypeName,
          description: `${operation.summary || operation.name} å“åº”ç±»å‹`,
          properties: {
            data: {
              type: 'unknown',
              required: false,
              description: 'å“åº”æ•°æ®'
            }
          }
        };
        nestedTypes.push(basicResponseType);
        collectedTypeNames.add(responseTypeName);
      }
      
      // å¤„ç†Requestç±»å‹ - ä½¿ç”¨æ–°çš„æ–¹æ³•åç”Ÿæˆ
      // ç»Ÿä¸€ä½¿ç”¨åŸºäºæ–¹æ³•åç”Ÿæˆçš„Requestç±»å‹å
      const requestTypeName = this.getSimpleName(this.generateDefaultRequestTypeName(operation), controllerName);
      
      if (!collectedTypeNames.has(requestTypeName)) {
        const basicRequestType: TypeDefinition = {
          name: requestTypeName,
          description: `${operation.summary || operation.name} è¯·æ±‚ç±»å‹`,
          properties: {}
        };
        (basicRequestType as any).isMissingRequestType = true;
        (basicRequestType as any).operationInfo = {
          operationId: operation.name,
          method: operation.method?.toUpperCase(),
          path: operation.path,
          summary: operation.summary
        };
        nestedTypes.push(basicRequestType);
        collectedTypeNames.add(requestTypeName);
      }
      
      {
        // å¦‚æœæ²¡æœ‰requestTypeï¼Œç”Ÿæˆé»˜è®¤çš„Requestç±»å‹
        const defaultRequestTypeName = this.getSimpleName(this.generateDefaultRequestTypeName(operation), controllerName);
        
        if (!collectedTypeNames.has(defaultRequestTypeName)) {
          const basicRequestType: TypeDefinition = {
            name: defaultRequestTypeName,
            description: `${operation.summary || operation.name} è¯·æ±‚ç±»å‹`,
            properties: {
              // å±æ€§å®šä¹‰å°†åœ¨åç»­çš„æ¥å£ç”Ÿæˆä¸­è¡¥å……
            }
          };
          
          // æ ‡è®°ä¸ºç¼ºå¤±çš„è¯·æ±‚ç±»å‹ï¼Œç”¨äºåç»­ç‰¹æ®Šå¤„ç†
          (basicRequestType as any).isMissingRequestType = true;
          // ä¿å­˜æ“ä½œä¿¡æ¯ï¼Œç”¨äºç”Ÿæˆæ›´è¯¦ç»†çš„æ–‡æ¡£æ³¨é‡Š
          (basicRequestType as any).operationInfo = {
            operationId: operation.name,
            method: operation.method?.toUpperCase(),
            path: operation.path,
            summary: operation.summary
          };
          
          nestedTypes.push(basicRequestType);
          collectedTypeNames.add(defaultRequestTypeName);
        }
      }
    }

    // ç”Ÿæˆç±»å‹å®šä¹‰ï¼ˆç›´æ¥åœ¨namespaceå†…ï¼‰
    if (nestedTypes.length > 0) {
      output += `\n`;
      for (const type of nestedTypes) {
        output += this.generateNamespaceInterface(type);
      }
    }

    // ä¸å†ç”Ÿæˆç‹¬ç«‹çš„éªŒè¯å‡½æ•°ï¼ŒRequestç±»è‡ªå¸¦validateæ–¹æ³•

    // ç”Ÿæˆ Client ç±»ï¼Œåœ¨namespaceå†…
    output += `\n  /** ${className} æ¨¡å—å®¢æˆ·ç«¯ */
  export class Client extends APIClient {`;

    // ç”Ÿæˆ API æ–¹æ³•
    for (const operation of allOperations) {
      output += this.generateApiMethodWithOptions(operation, controllerName, true);
    }

    output += `
  }
}
`;

    return output;
  }

  /**
   * ç”Ÿæˆå¸¦ options çš„ API æ–¹æ³• - ç›´æ¥è°ƒç”¨executeRequest
   */
  private generateApiMethodWithOptions(operation: APIOperation, controllerName?: string, hasNamespace: boolean = true): string {
    const hasRequest = !!(operation.requestType && operation.requestType !== 'void');
    // ç§»é™¤æ§åˆ¶å™¨å‰ç¼€ï¼Œåªä¿ç•™æ–¹æ³•å
    // ä¾‹å¦‚: analyticshandler_getsegmentedreport -> getsegmentedreport
    // åŸºäºè·¯å¾„ç”Ÿæˆæ›´å‡†ç¡®çš„æ–¹æ³•å
    const methodName = this.generateMethodNameFromPath(operation);
    
    // ä½¿ç”¨åµŒå¥—ç±»çš„ç±»å‹åç§°ï¼ˆå¸¦namespaceå‰ç¼€ï¼Œç”¨äºç±»å‹å£°æ˜ï¼‰
    // ç»Ÿä¸€ä½¿ç”¨åŸºäºæ–¹æ³•åç”Ÿæˆçš„ç±»å‹åï¼Œç¡®ä¿ä¸€è‡´æ€§
    const requestType = this.getNestedTypeName(this.generateDefaultRequestTypeName(operation), controllerName, hasNamespace);
    const responseType = this.getNestedTypeName(this.generateDefaultResponseTypeName(operation), controllerName, hasNamespace);
      
    // ç±»å‹åç§°å¤„ç†åœ¨executeRequestè°ƒç”¨ä¸­ç›´æ¥å®Œæˆ
    
    // æå–è·¯å¾„å‚æ•°
    const pathParams = (operation.parameters || []).filter(p => p && p.in === 'path');
    
    
    // ç”Ÿæˆè·¯å¾„å‚æ•°åˆ—è¡¨
    const pathParamsList = pathParams.map(p => `${p.name}: ${p.type}`).join(', ');
    const pathParamsPrefix = pathParamsList ? `${pathParamsList}, ` : '';
    
    // ç”Ÿæˆè·¯å¾„è¡¨è¾¾å¼ï¼ˆä½¿ç”¨æ¨¡æ¿å­—ç¬¦ä¸²ï¼‰
    let pathExpression: string;
    if (pathParams.length > 0) {
      // å°† {param} æ›¿æ¢ä¸º ${param}ï¼Œç”Ÿæˆæ¨¡æ¿å­—ç¬¦ä¸²
      const templatePath = operation.path.replace(/\{([^}]+)\}/g, '${$1}');
      pathExpression = `\`${templatePath}\``;
    } else {
      pathExpression = `'${operation.path}'`;
    }
    
    // ç”Ÿæˆå‚æ•°åˆ—è¡¨
    const requestParam = hasRequest ? `request: ${requestType}, ` : '';
    const requestArg = hasRequest ? 'request' : `new ${requestType.includes('.') ? requestType.split('.')[1] : requestType}()`;
    
    // ç”ŸæˆéªŒè¯ä»£ç ï¼ˆå¦‚æœéœ€è¦ï¼‰
    const validationCode = hasRequest ? `      await request.validate();\n` : '';
    
    return `  /**
   * ${operation.summary || methodName}
   * 
   * @description Execute ${operation.summary || methodName} operation
   * @method ${operation.method.toUpperCase()}
   * @path ${operation.path}
   * 
   * ${pathParams.map(p => `@param {${p.type}} ${p.name} - Path parameter`).join('\n   * ')}${pathParams.length > 0 ? '\n   * ' : ''}${hasRequest ? `@param {${requestType.includes('.') ? requestType.split('.')[1] : requestType}} request - Request parameters\n   * ` : ''}@param {...APIOption} options - Functional option parameters
   * @returns {Promise<${responseType.includes('.') ? responseType.split('.')[1] : responseType}>} Returns API response result
   * 
   * @example
   * const result = await api.${methodName}(${pathParams.map(p => p.name).join(', ')}${pathParams.length > 0 && hasRequest ? ', ' : ''}${hasRequest ? 'request' : ''});
   * 
   * @throws {Error} Throws error when request fails or parameter validation fails
   */
  async ${methodName}(${pathParamsPrefix}${requestParam}...options: APIOption[]): Promise<${responseType.includes('.') ? responseType.split('.')[1] : responseType}> {
${validationCode}
    return this.executeRequest<${requestType.includes('.') ? requestType.split('.')[1] : requestType}, ${responseType.includes('.') ? responseType.split('.')[1] : responseType}>(
      HttpMethod.${operation.method.toUpperCase()},
      ${pathExpression},
      ${requestArg},
      ${responseType.includes('.') ? responseType.split('.')[1] : responseType},
      options
    );
  }

`;
  }

  /**
   * è½¬ä¹‰æ­£åˆ™è¡¨è¾¾å¼ç‰¹æ®Šå­—ç¬¦
   */
  private escapeRegExp(str: string): string {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  /**
   * è·å–namespaceå†…çš„ç±»å‹åç§°ï¼Œå¦‚æœæ²¡æœ‰å¤æ‚ç±»å‹åˆ™è¿”å›åŸºç¡€ç±»å‹
   */
  /**
   * è·å–namespaceå†…çš„ç±»å‹åç§°ï¼Œå¦‚æœæ²¡æœ‰å¤æ‚ç±»å‹åˆ™è¿”å›åŸºç¡€ç±»å‹
   */
  private getNestedTypeName(typeName: string, controllerName?: string, hasNamespace: boolean = true): string {
    if (!controllerName || !hasNamespace) {
      // å¦‚æœæ²¡æœ‰namespaceï¼Œè¿”å›åŸºç¡€ç±»å‹
      return typeName;
    }
    
    // ç§»é™¤ç±»å‹åç§°ä¸­çš„æ§åˆ¶å™¨å‰ç¼€
    // ä¾‹å¦‚: "AnalyticshandlerGetsegmentedreportResponse" -> "GetsegmentedreportResponse"
    let simplifiedName = typeName;
    
    // ç§»é™¤æ§åˆ¶å™¨åç§°å‰ç¼€ï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰
    const controllerPrefix = this.toPascalCase(controllerName);
    if (simplifiedName.startsWith(controllerPrefix)) {
      simplifiedName = simplifiedName.substring(controllerPrefix.length);
    }
    
    // ç¡®ä¿æ˜¯PascalCase
    simplifiedName = this.toPascalCase(simplifiedName);
    
    // è¿”å›namespaceå½¢å¼
    return `${controllerPrefix}.${simplifiedName}`;
  }



  /**
   * åœ¨å‘½åç©ºé—´å†…ç”Ÿæˆæ¥å£å®šä¹‰ - ä½¿ç”¨class-validatorè£…é¥°å™¨
   */
  private generateNamespaceInterface(type: TypeDefinition): string {
    // æ£€æŸ¥æ˜¯å¦ä¸ºç¼ºå¤±çš„Requestç±»å‹
    const isMissingRequest = (type as any).isMissingRequestType;
    const operationInfo = (type as any).operationInfo;
    
    if (isMissingRequest && operationInfo) {
      // ä¸ºç¼ºå¤±çš„Requestç±»å‹ç”Ÿæˆè¯¦ç»†çš„æ–‡æ¡£æ³¨é‡Šï¼ŒåŒ…å«ç¼ºå¤±åŸå› å’Œè§£å†³æ–¹æ¡ˆ
      return `  /** 
   * ${type.description || type.name + ' data type'}
   * 
   * Note: This request type definition is incomplete
   * 
   * Missing reason:
   * â€¢ The requestBody definition for ${operationInfo.method} ${operationInfo.path} operation in OpenAPI specification is incomplete
   * â€¢ May lack specific schema definition or property description
   * 
     * For server-side developers to improve:
     * 1. Complete @ApiBody() decorator in Controller
     * 2. Add complete DTO class definition and use @ApiProperty() decorator
     * 3. Ensure OpenAPI specification includes detailed requestBody.content.application/json.schema
     * 4. Regenerate OpenAPI specification documentation
     * 
     * Server-side improvement example:
     * \`\`\`typescript
     * @ApiBody({ type: ${type.name} })
     * async ${operationInfo.operationId?.split('_')[1] || 'methodName'}(@Body() request: ${type.name}) {
     *   // Implementation logic
     * }
     * \`\`\`
     * 
     * For client developers:
     * â€¢ This type is temporarily an empty object, please use according to actual API documentation
     * â€¢ After server-side improvement, regenerate SDK to get complete type definition
   */
  export class ${type.name} {
    // æ³¨æ„: éœ€è¦æ ¹æ®å…·ä½“APIéœ€æ±‚æ·»åŠ å±æ€§å®šä¹‰
    // å¯ä»¥å‚è€ƒ ${operationInfo.operationId} çš„APIæ–‡æ¡£æˆ–æœåŠ¡ç«¯DTOå®šä¹‰

    /** éªŒè¯è¯·æ±‚æ•°æ® */
    async validate(): Promise<void> {
      const errors = await validate(this);
      
      if (errors.length > 0) {
        const errorDetails = errors.map(error => {
          const property = error.property || 'unknown';
          const constraints = error.constraints || {};
          const constraintMessages = Object.values(constraints).join(', ');
          const value = error.value !== undefined ? JSON.stringify(error.value) : 'undefined';
          return \`å±æ€§ '\${property}' éªŒè¯å¤±è´¥: \${constraintMessages} (å½“å‰å€¼: \${value})\`;
        }).join('\\n');
        
        throw new Error(\`Request data validation failed:\\n\${errorDetails}\\n\\nPlease check the following:\\n1. Ensure all required fields are provided\\n2. Check if field types are correct (string/number/array etc.)\\n3. Verify field formats meet requirements\\n4. If the problem persists, please contact server-side developers to check API specification\`);
      }
    }
  }

`;
    }
    
    // æ­£å¸¸çš„ç±»å‹å®šä¹‰
    const properties = Object.entries(type.properties)
      .map(([name, prop]) => {
        const decorators = this.generatePropertyDecorators(prop);
        const assertion = prop.required ? '!' : '?'; // å¿…éœ€å±æ€§ä½¿ç”¨!æ–­è¨€ï¼Œå¯é€‰å±æ€§ä½¿ç”¨?
        const comment = prop.description ? ` // ${prop.description}` : '';
        
        return `${decorators}    ${name}${assertion}: ${prop.type};${comment}`;
      })
      .join('\n\n');

    // ä¸ºRequestç±»æ·»åŠ validateæ–¹æ³•
    const validateMethod = type.name.toLowerCase().includes('request') ? `

    /** éªŒè¯è¯·æ±‚æ•°æ® */
    async validate(): Promise<void> {
      const errors = await validate(this);
      
      if (errors.length > 0) {
        const errorDetails = errors.map(error => {
          const property = error.property || 'unknown';
          const constraints = error.constraints || {};
          const constraintMessages = Object.values(constraints).join(', ');
          const value = error.value !== undefined ? JSON.stringify(error.value) : 'undefined';
          return \`å±æ€§ '\${property}' éªŒè¯å¤±è´¥: \${constraintMessages} (å½“å‰å€¼: \${value})\`;
        }).join('\\n');
        
        throw new Error(\`Request data validation failed:\\n\${errorDetails}\\n\\nPlease check the following:\\n1. Ensure all required fields are provided\\n2. Check if field types are correct (string/number/array etc.)\\n3. Verify field formats meet requirements\\n4. If the problem persists, please contact server-side developers to check API specification\`);
      }
    }` : '';

    return `  /** ${type.description || type.name + ' data type'} */
  export class ${type.name} {
${properties}${validateMethod}
  }

`;
  }

  /**
   * åŸºäºOpenAPIå±æ€§ç”Ÿæˆclass-validatorè£…é¥°å™¨
   */
  private generatePropertyDecorators(prop: TypeProperty, typeNameMapping?: Map<string, string>): string {
    const decorators: string[] = [];

    // æ£€æŸ¥æ˜¯å¦ä¸ºæ•°ç»„ç±»å‹
    if (prop.type.endsWith('[]')) {
      // æ•°ç»„ç±»å‹éœ€è¦ç‰¹æ®Šå¤„ç†
      const itemType = prop.type.slice(0, -2); // ç§»é™¤ '[]' åç¼€

      // åªæœ‰å¤æ‚å¯¹è±¡æ•°ç»„æ‰éœ€è¦ ClassArrayï¼ŒåŸºç¡€ç±»å‹æ•°ç»„ä¸éœ€è¦
      if (this.isComplexType(itemType)) {
        // å¤æ‚ç±»å‹æ•°ç»„ï¼ˆå¦‚ User[]ã€Msg[]ï¼‰ä½¿ç”¨ @Type è£…é¥°å™¨
        const mappedType = typeNameMapping?.get(itemType) || itemType;
        decorators.push(`    @Type(() => ${mappedType})`);
      }
      // åŸºç¡€ç±»å‹æ•°ç»„ï¼ˆstring[]ã€number[]ã€boolean[]ï¼‰å’Œå†…ç½®ç±»å‹ä¸éœ€è¦ç‰¹æ®Šè£…é¥°å™¨

      // å¯é€‰å­—æ®µè£…é¥°å™¨ï¼ˆæ ¹æ® required å­—æ®µï¼‰
      if (!prop.required) {
        decorators.push('    @IsOptional()');
      }

      return decorators.length > 0 ? decorators.join('\n') + '\n' : '';
    }

    // åŸºç¡€ç±»å‹è£…é¥°å™¨
    switch (prop.type) {
      case 'string':
        decorators.push('    @IsString()');
        break;
      case 'number':
      case 'integer':
        decorators.push('    @IsNumber()');
        break;
      case 'boolean':
        decorators.push('    @IsBoolean()');
        break;
    }

    // å¯é€‰å­—æ®µè£…é¥°å™¨
    if (!prop.required) {
      decorators.push('    @IsOptional()');
    }

    // æ ¼å¼éªŒè¯è£…é¥°å™¨
    if (prop.format === 'email') {
      decorators.push('    @IsEmail()');
    }

    // æ•°å€¼èŒƒå›´è£…é¥°å™¨
    if (prop.minimum !== undefined) {
      decorators.push(`    @Min(${prop.minimum})`);
    }
    if (prop.maximum !== undefined) {
      decorators.push(`    @Max(${prop.maximum})`);
    }

    // å­—ç¬¦ä¸²é•¿åº¦è£…é¥°å™¨
    if (prop.minLength !== undefined || prop.maxLength !== undefined) {
      const min = prop.minLength || 0;
      const max = prop.maxLength || 10000;
      decorators.push(`    @MinLength(${min})`);
      decorators.push(`    @MaxLength(${max})`);
    }

    // æ­£åˆ™è¡¨è¾¾å¼è£…é¥°å™¨
    if (prop.pattern) {
      decorators.push(`    @Matches(/${prop.pattern}/)`);
    }

    return decorators.length > 0 ? decorators.join('\n') + '\n' : '';
  }

  /**
   * åˆ¤æ–­æ˜¯å¦ä¸ºå¤æ‚ç±»å‹ï¼ˆéœ€è¦ä½¿ç”¨ ClassArray çš„ç±»å‹ï¼‰
   */
  private isComplexType(type: string): boolean {
    // åŸºç¡€ç±»å‹ä¸éœ€è¦ ClassArray
    const primitiveTypes = [
      'string', 'number', 'boolean', 'integer',
      'object', 'any', 'unknown', 'void', 'null', 'undefined'
    ];

    // TypeScript å†…ç½®ç±»å‹ä¸éœ€è¦ ClassArray
    const builtinTypes = [
      'Date', 'RegExp', 'Error', 'Map', 'Set', 'WeakMap', 'WeakSet',
      'Array', 'Promise', 'Function', 'Object', 'Record'
    ];

    // æ³›å‹ç±»å‹é€šå¸¸ä¸éœ€è¦ ClassArray
    if (type.includes('<') || type.includes('>')) {
      return false;
    }

    // è”åˆç±»å‹ä¸éœ€è¦ ClassArray
    if (type.includes('|')) {
      return false;
    }

    // æ£€æŸ¥æ˜¯å¦ä¸ºåŸºç¡€ç±»å‹æˆ–å†…ç½®ç±»å‹
    if (primitiveTypes.includes(type.toLowerCase()) || builtinTypes.includes(type)) {
      return false;
    }

    // é¦–å­—æ¯å¤§å†™çš„ç±»å‹åï¼Œä¸”ä¸åœ¨æ’é™¤åˆ—è¡¨ä¸­ï¼Œè®¤ä¸ºæ˜¯å¤æ‚çš„è‡ªå®šä¹‰ç±»å‹
    return /^[A-Z][a-zA-Z0-9]*$/.test(type);
  }


  /**
   * åœ¨å‘½åç©ºé—´å†…ç”ŸæˆAPIæ–¹æ³•
   */
  private generateNamespaceApiMethod(operation: APIOperation, controllerName?: string, controllerTypes?: Map<string, TypeDefinition>): string {
    // ç”Ÿæˆæ™ºèƒ½æ–¹æ³•åï¼šåŸºäºè·¯å¾„å’ŒHTTPæ–¹æ³•
    const methodName = this.generateIntelligentMethodName(operation);
    
    // ç®€åŒ–ç±»å‹åï¼Œæ£€æŸ¥æ˜¯å¦å­˜åœ¨äºcontrollerTypesä¸­
    const requestType = operation.requestType ? 
      this.getSimpleName(operation.requestType, controllerName) : undefined;
    const responseType = operation.responseType ?
      this.getSimpleName(operation.responseType, controllerName) : 
      this.getSimpleName(this.generateDefaultResponseTypeName(operation), controllerName);
      
    // æ£€æŸ¥æ˜¯å¦æœ‰å¤æ‚ç±»å‹ï¼ˆéœ€è¦ä½¿ç”¨ç®€åŒ–åç§°æ£€æŸ¥ï¼‰
    const simplifiedRequestName = operation.requestType ? 
      this.getSimpleName(operation.requestType, controllerName) : undefined;
    const simplifiedResponseName = operation.responseType ?
      this.getSimpleName(operation.responseType, controllerName) : undefined;
      
    const hasComplexRequestType = simplifiedRequestName && controllerTypes && 
      Array.from(controllerTypes.values()).some(type => type.name === simplifiedRequestName);
    const hasComplexResponseType = simplifiedResponseName && controllerTypes &&
      Array.from(controllerTypes.values()).some(type => type.name === simplifiedResponseName);
      

    // æå–è·¯å¾„å‚æ•°
    const pathParams = (operation.parameters || []).filter(p => p && p.in === 'path');
    
    const hasRequest = !!(operation.requestType && operation.requestType !== 'void');
    const finalRequestType = hasRequest ? 
      (hasComplexRequestType ? requestType : 'any') : undefined;
    const finalResponseType = responseType; // æ€»æ˜¯ä½¿ç”¨å…·ä½“çš„å“åº”ç±»å‹ï¼Œä¸å›é€€åˆ° any
    
    // ç”Ÿæˆè·¯å¾„å‚æ•°åˆ—è¡¨
    const pathParamsList = pathParams.map(p => `${p.name}: ${p.type}`).join(', ');
    const pathParamsPrefix = pathParamsList ? `${pathParamsList}, ` : '';
    
    const requestParam = hasRequest ? `request: ${finalRequestType}, ` : '';
    const requestArg = hasRequest ? 'request' : `new ${finalRequestType}()`;
    
    // ç”Ÿæˆè·¯å¾„è¡¨è¾¾å¼ï¼ˆä½¿ç”¨æ¨¡æ¿å­—ç¬¦ä¸²ï¼‰
    let pathExpression: string;
    if (pathParams.length > 0) {
      // å°† {param} æ›¿æ¢ä¸º ${param}ï¼Œç”Ÿæˆæ¨¡æ¿å­—ç¬¦ä¸²
      const templatePath = operation.path.replace(/\{([^}]+)\}/g, '${$1}');
      pathExpression = `\`${templatePath}\``;
    } else {
      pathExpression = `'${operation.path}'`;
    }
    
    // ç”ŸæˆéªŒè¯å‡½æ•°è°ƒç”¨ï¼ˆç›´æ¥è°ƒç”¨request.validate()ï¼‰
    const validationCall = hasRequest && hasComplexRequestType ? 
      `      await request.validate();\n` : '';

    return `
    /** ${operation.summary || methodName} */
    async ${methodName}(${pathParamsPrefix}${requestParam}...options: APIOption[]): Promise<${finalResponseType}> {
${validationCall}
      return this.executeRequest<${finalRequestType || 'Record<string, never>'}, ${finalResponseType}>(
        HttpMethod.${operation.method.toUpperCase()},
        ${pathExpression},
        ${requestArg},
        ${finalResponseType},
        options
      );
    }`;
  }

  /**
   * ç”Ÿæˆé»˜è®¤å“åº”ç±»å‹å
   */
  private generateDefaultResponseTypeName(operation: APIOperation): string {
    const methodName = this.generateMethodNameFromPath(operation);
    return `${this.toPascalCase(methodName)}Response`;
  }

  /**
   * ç”Ÿæˆé»˜è®¤è¯·æ±‚ç±»å‹å
   */
  private generateDefaultRequestTypeName(operation: APIOperation): string {
    const methodName = this.generateMethodNameFromPath(operation);
    return `${this.toPascalCase(methodName)}Request`;
  }

  /**
   * ç®€åŒ–æ–¹æ³•åï¼šåŸºäºoperationIdå’Œè·¯å¾„æ™ºèƒ½ç”Ÿæˆæ–¹æ³•å
   */
  private simplifyMethodName(operationName: string): string {
    // ç§»é™¤æ§åˆ¶å™¨å‰ç¼€
    let simplified = operationName.replace(/^.+?Controller_/i, '').replace(/^.+?controller_/i, '');
    
    // è½¬æ¢ä¸ºcamelCaseï¼ˆé¦–å­—æ¯å°å†™ï¼‰
    return camelCase(simplified);
  }

  /**
   * åŸºäºè·¯å¾„å’ŒHTTPæ–¹æ³•ç”Ÿæˆæ™ºèƒ½çš„æ–¹æ³•å
   */
  private generateIntelligentMethodName(operation: APIOperation): string {
    if (!operation.path || !operation.method) {
      return this.simplifyMethodName(operation.name);
    }

    // ç›´æ¥å®ç°è·¯å¾„è§£æé€»è¾‘ï¼Œé¿å…åŠ¨æ€å¯¼å…¥
    try {
      const httpMethod = operation.method.toLowerCase();
      const pathSegments = operation.path.split('/').filter(Boolean);
      
      // åˆ†æè·¯å¾„ç»“æ„
      const params = pathSegments.filter(seg => seg.includes('{'));
      const versionSegment = pathSegments.find(seg => /^v\d+$/i.test(seg));
      const versionPrefix = versionSegment ? versionSegment.toUpperCase() : null;
      const pathAnalysis = {
        paramCount: params.length,
        versionPrefix
      };
      
      // åŸºäºHTTPæ–¹æ³•å’Œè·¯å¾„ç»“æ„ç”Ÿæˆæ–¹æ³•å
      let methodName = '';
      
      switch (httpMethod) {
        case 'get':
          methodName = this.generateGetMethodName(pathAnalysis, pathSegments);
          break;
        case 'post':
          methodName = this.generatePostMethodName(pathAnalysis, pathSegments);
          break;
        case 'put':
          methodName = this.generatePutMethodName(pathAnalysis, pathSegments);
          break;
        case 'patch':
          methodName = this.generatePatchMethodName(pathAnalysis, pathSegments);
          break;
        case 'delete':
          methodName = this.generateDeleteMethodName(pathAnalysis, pathSegments);
          break;
        default:
          methodName = httpMethod;
      }
      
      return camelCase(methodName);
    } catch (error) {
      // å¦‚æœå‡ºé”™ï¼Œå›é€€åˆ°åŸå§‹é€»è¾‘
      return this.simplifyMethodName(operation.name);
    }
  }

  /**
   * ç”ŸæˆGETæ–¹æ³•å - åŸºäºURIç»“æ„ï¼Œä¾¿äºè¯†åˆ«å¯¹åº”è·¯å¾„ï¼ŒåŒ…å«ç‰ˆæœ¬ä¿¡æ¯
   */
  private generateGetMethodName(analysis: any, pathSegments: string[]): string {
    const { paramCount, versionPrefix } = analysis;
    
    // è¿‡æ»¤æ‰å¸¸è§çš„APIå‰ç¼€ï¼Œä½†ä¿ç•™ç‰ˆæœ¬ä¿¡æ¯ï¼Œè·å–å®é™…çš„ä¸šåŠ¡èµ„æºè·¯å¾„
    const businessSegments = pathSegments.filter(seg => 
      !seg.includes('{') && 
      !['api'].includes(seg.toLowerCase()) &&
      !/^v\d+$/i.test(seg)  // ç‰ˆæœ¬ä¿¡æ¯å•ç‹¬å¤„ç†
    );
    
    if (businessSegments.length === 0) {
      const baseMethodName = paramCount > 0 ? 'getById' : 'getList';
      return versionPrefix ? `get${versionPrefix}${baseMethodName.slice(3)}` : baseMethodName;
    }
    
    // æ„å»ºèµ„æºè·¯å¾„
    const resourcePath = businessSegments.map(seg => this.toPascalCase(seg)).join('');
    
    // æ„å»ºåŸºç¡€æ–¹æ³•å
    let baseMethodName: string;
    if (paramCount > 0) {
      baseMethodName = `get${resourcePath}ById`;
    } else {
      baseMethodName = `get${resourcePath}`;
    }
    
    // å¦‚æœæœ‰ç‰ˆæœ¬ä¿¡æ¯ï¼Œåœ¨æ–¹æ³•åä¸­ä½“ç°
    return versionPrefix ? `get${versionPrefix}${baseMethodName.slice(3)}` : baseMethodName;
  }

  /**
   * ç”ŸæˆPOSTæ–¹æ³•å - åŸºäºURIç»“æ„ï¼Œä¾¿äºè¯†åˆ«å¯¹åº”è·¯å¾„ï¼ŒåŒ…å«ç‰ˆæœ¬ä¿¡æ¯
   */
  private generatePostMethodName(analysis: any, pathSegments: string[]): string {
    const { versionPrefix } = analysis;
    
    // è¿‡æ»¤æ‰å¸¸è§çš„APIå‰ç¼€ï¼Œä½†ä¿ç•™ç‰ˆæœ¬ä¿¡æ¯ï¼Œè·å–å®é™…çš„ä¸šåŠ¡èµ„æºè·¯å¾„
    const businessSegments = pathSegments.filter(seg => 
      !seg.includes('{') && 
      !['api'].includes(seg.toLowerCase()) &&
      !/^v\d+$/i.test(seg)  // ç‰ˆæœ¬ä¿¡æ¯å•ç‹¬å¤„ç†
    );
    
    if (businessSegments.length === 0) {
      return versionPrefix ? `create${versionPrefix}` : 'create';
    }
    
    // æ„å»ºèµ„æºè·¯å¾„
    const resourcePath = businessSegments.map(seg => this.toPascalCase(seg)).join('');
    const baseMethodName = `create${resourcePath}`;
    
    // å¦‚æœæœ‰ç‰ˆæœ¬ä¿¡æ¯ï¼Œåœ¨æ–¹æ³•åä¸­ä½“ç°
    return versionPrefix ? `create${versionPrefix}${baseMethodName.slice(6)}` : baseMethodName;
  }

  /**
   * ç”ŸæˆPUTæ–¹æ³•å - åŸºäºURIç»“æ„ï¼Œä¾¿äºè¯†åˆ«å¯¹åº”è·¯å¾„ï¼ŒåŒ…å«ç‰ˆæœ¬ä¿¡æ¯
   */
  private generatePutMethodName(analysis: any, pathSegments: string[]): string {
    const { versionPrefix } = analysis;
    
    // è¿‡æ»¤æ‰å¸¸è§çš„APIå‰ç¼€ï¼Œä½†ä¿ç•™ç‰ˆæœ¬ä¿¡æ¯ï¼Œè·å–å®é™…çš„ä¸šåŠ¡èµ„æºè·¯å¾„
    const businessSegments = pathSegments.filter(seg => 
      !seg.includes('{') && 
      !['api'].includes(seg.toLowerCase()) &&
      !/^v\d+$/i.test(seg)  // ç‰ˆæœ¬ä¿¡æ¯å•ç‹¬å¤„ç†
    );
    
    if (businessSegments.length === 0) {
      return versionPrefix ? `update${versionPrefix}` : 'update';
    }
    
    // æ„å»ºèµ„æºè·¯å¾„
    const resourcePath = businessSegments.map(seg => this.toPascalCase(seg)).join('');
    const baseMethodName = `update${resourcePath}`;
    
    // å¦‚æœæœ‰ç‰ˆæœ¬ä¿¡æ¯ï¼Œåœ¨æ–¹æ³•åä¸­ä½“ç°
    return versionPrefix ? `update${versionPrefix}${baseMethodName.slice(6)}` : baseMethodName;
  }

  /**
   * ç”ŸæˆPATCHæ–¹æ³•å - åŸºäºURIç»“æ„ï¼Œä¾¿äºè¯†åˆ«å¯¹åº”è·¯å¾„ï¼ŒåŒ…å«ç‰ˆæœ¬ä¿¡æ¯
   */
  private generatePatchMethodName(analysis: any, pathSegments: string[]): string {
    const { versionPrefix } = analysis;
    
    // è¿‡æ»¤æ‰å¸¸è§çš„APIå‰ç¼€ï¼Œä½†ä¿ç•™ç‰ˆæœ¬ä¿¡æ¯ï¼Œè·å–å®é™…çš„ä¸šåŠ¡èµ„æºè·¯å¾„
    const businessSegments = pathSegments.filter(seg => 
      !seg.includes('{') && 
      !['api'].includes(seg.toLowerCase()) &&
      !/^v\d+$/i.test(seg)  // ç‰ˆæœ¬ä¿¡æ¯å•ç‹¬å¤„ç†
    );
    
    if (businessSegments.length === 0) {
      return versionPrefix ? `patch${versionPrefix}` : 'patch';
    }
    
    // æ„å»ºèµ„æºè·¯å¾„
    const resourcePath = businessSegments.map(seg => this.toPascalCase(seg)).join('');
    const baseMethodName = `patch${resourcePath}`;
    
    // å¦‚æœæœ‰ç‰ˆæœ¬ä¿¡æ¯ï¼Œåœ¨æ–¹æ³•åä¸­ä½“ç°
    return versionPrefix ? `patch${versionPrefix}${baseMethodName.slice(5)}` : baseMethodName;
  }

  /**
   * ç”ŸæˆDELETEæ–¹æ³•å - åŸºäºURIç»“æ„ï¼Œä¾¿äºè¯†åˆ«å¯¹åº”è·¯å¾„ï¼ŒåŒ…å«ç‰ˆæœ¬ä¿¡æ¯
   */
  private generateDeleteMethodName(analysis: any, pathSegments: string[]): string {
    const { versionPrefix } = analysis;
    
    // è¿‡æ»¤æ‰å¸¸è§çš„APIå‰ç¼€ï¼Œä½†ä¿ç•™ç‰ˆæœ¬ä¿¡æ¯ï¼Œè·å–å®é™…çš„ä¸šåŠ¡èµ„æºè·¯å¾„
    const businessSegments = pathSegments.filter(seg => 
      !seg.includes('{') && 
      !['api'].includes(seg.toLowerCase()) &&
      !/^v\d+$/i.test(seg)  // ç‰ˆæœ¬ä¿¡æ¯å•ç‹¬å¤„ç†
    );
    
    if (businessSegments.length === 0) {
      return versionPrefix ? `delete${versionPrefix}` : 'delete';
    }
    
    // æ„å»ºèµ„æºè·¯å¾„
    const resourcePath = businessSegments.map(seg => this.toPascalCase(seg)).join('');
    const baseMethodName = `delete${resourcePath}`;
    
    // å¦‚æœæœ‰ç‰ˆæœ¬ä¿¡æ¯ï¼Œåœ¨æ–¹æ³•åä¸­ä½“ç°
    return versionPrefix ? `delete${versionPrefix}${baseMethodName.slice(6)}` : baseMethodName;
  }





  /**
   * åŸºäºè·¯å¾„ç”Ÿæˆæ–¹æ³•å
   */
  private generateMethodNameFromPath(operation: APIOperation): string {
    const path = operation.path;
    const method = operation.method?.toLowerCase() || 'get';
    
    // ç§»é™¤è·¯å¾„å‚æ•° {param}ï¼Œä¿ç•™è·¯å¾„ç»“æ„
    const cleanPath = path.replace(/\{[^}]+\}/g, '');
    
    // ç§»é™¤å¼€å¤´çš„ /api/ ç­‰å‰ç¼€ï¼Œå¹¶åˆ†å‰²æˆå•è¯
    const pathSegments = cleanPath.split('/').filter(seg => 
      seg && !['api', 'v1', 'v2'].includes(seg.toLowerCase())
    );
    
    // å°†æ¯ä¸ªè·¯å¾„æ®µåˆ†å‰²æˆå•è¯ï¼ˆå¤„ç†é©¼å³°ã€ä¸‹åˆ’çº¿ã€è¿å­—ç¬¦ï¼‰
    const words: string[] = [];
    pathSegments.forEach(segment => {
      // å¤„ç†é©¼å³°å‘½åï¼šsystemId -> system, Id
      const camelWords = segment.replace(/([a-z])([A-Z])/g, '$1 $2');
      // å¤„ç†ä¸‹åˆ’çº¿å’Œè¿å­—ç¬¦
      const splitWords = camelWords.split(/[-_]/);
      // è½¬æ¢ä¸ºå°å†™å¹¶è¿‡æ»¤ç©ºå­—ç¬¦ä¸²
      words.push(...splitWords.map(w => w.toLowerCase()).filter(w => w));
    });
    
    // ç”Ÿæˆæ–¹æ³•åï¼šHTTPæ–¹æ³• + è·¯å¾„å•è¯
    const methodPrefix = method === 'get' ? 'get' : 
                        method === 'post' ? 'create' :
                        method === 'put' ? 'update' :
                        method === 'delete' ? 'delete' :
                        method === 'patch' ? 'patch' : method;
    
    // ç»„åˆæˆé©¼å³°å‘½å
    const pathName = words.map((word, index) => 
      index === 0 ? word : word.charAt(0).toUpperCase() + word.slice(1)
    ).join('');
    
    let methodName = `${methodPrefix}${pathName.charAt(0).toUpperCase()}${pathName.slice(1)}`;
    
    // å¤„ç†é‡å¤æ–¹æ³•åï¼šå¦‚æœæœ‰è·¯å¾„å‚æ•°ï¼Œæ·»åŠ Byå‚æ•°å
    const pathParams = (operation.parameters || []).filter(p => p && p.in === 'path');
    if (pathParams.length > 0) {
      const paramNames = pathParams.map(p => p.name.charAt(0).toUpperCase() + p.name.slice(1)).join('');
      methodName = `${methodPrefix}${pathName.charAt(0).toUpperCase()}${pathName.slice(1)}By${paramNames}`;
    }
    
    return methodName;
  }

  /**
   * è·å–ç®€åŒ–çš„ç±»å‹åç§°ï¼ˆç”¨äºå¤šå¤„è°ƒç”¨ï¼‰
   */
  private getSimpleName(typeName: string, controllerName?: string): string {
    if (!controllerName) return typeName;
    
    const controllerPrefix = this.toPascalCase(controllerName);
    let simplifiedName = typeName;
    
    if (simplifiedName.startsWith(controllerPrefix)) {
      simplifiedName = simplifiedName.substring(controllerPrefix.length);
    }
    
    return this.toPascalCase(simplifiedName);
  }

  /**
   * ç”Ÿæˆä¸»å…¥å£æ–‡ä»¶
   */
  private generateIndexFile(controllerNames: string[]): string {
    let output = `// API å®¢æˆ·ç«¯ä¸»å…¥å£æ–‡ä»¶\n\n`;
    
    // å¯¼å‡ºç±»å‹å®šä¹‰
    output += `export * from './src/client';\n\n`;
    
    // å¯¼å‡ºæ‰€æœ‰ Controller
    for (const controllerName of controllerNames) {
      const fileName = controllerName.toLowerCase();
      const className = controllerName; // ä¸æ‹¼æ¥Apiåç¼€
      output += `export { ${className} } from './src/${fileName}';\n`;
    }
    
    output += `\n
import { HttpBuilder } from 'openapi-ts-sdk';
`;
    
    // å¯¼å…¥æ‰€æœ‰ Controller ç±»
    for (const controllerName of controllerNames) {
      const className = controllerName; // ä¸æ‹¼æ¥Apiåç¼€
      output += `import { ${className} } from './src/${controllerName.toLowerCase()}';\n`;
    }
    
    output += `
export class Client {
`;
    
    // åˆ›å»ºå„ä¸ª Controller çš„å®ä¾‹
    for (const controllerName of controllerNames) {
      const propertyName = controllerName.toLowerCase();
      output += `  public readonly ${propertyName}: ${controllerName}.Client;\n`;
    }
    
    output += `

  constructor(httpBuilder: HttpBuilder) {`;
    
    // åˆå§‹åŒ–å„ä¸ª Controller
    for (const controllerName of controllerNames) {
      const propertyName = controllerName.toLowerCase();
      output += `
    this.${propertyName} = new ${controllerName}.Client(httpBuilder);`;
    }
    
    output += `
  }
}
`;
    
    return output;
  }

  /**
   * ç”Ÿæˆ API æ–¹æ³•ï¼ˆå‘åå…¼å®¹ï¼‰
   */
  private generateApiMethod(operation: APIOperation): string {
    return this.generateApiMethodWithOptions(operation);
  }
}

// é‡æ–°å¯¼å‡º API ç›¸å…³ç±»å‹
export * from './openapi-parser';