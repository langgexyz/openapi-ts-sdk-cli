#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import https from 'https';
import http from 'http';
import { Command } from 'commander';
import { OpenAPIParser, OpenAPISpec } from './generator/openapi-parser';
import { CodeGenerator } from './generator/code-generator';

interface PackageJsonStructure {
  name: string;
  version: string;
  description: string;
  main: string;
  types: string;
  scripts?: Record<string, string>;
  dependencies: Record<string, string>;
  devDependencies?: Record<string, string>;
}

/**
 * Ê£ÄÊµãËæìÂÖ•ÊòØÂê¶‰∏∫ URL
 */
function isUrl(input: string): boolean {
  return input.startsWith('http://') || input.startsWith('https://');
}

/**
 * ‰ªé URL Ëé∑ÂèñÂÜÖÂÆπ
 */
function fetchFromUrl(url: string): Promise<string> {
  return new Promise((resolve, reject) => {
    const client = url.startsWith('https://') ? https : http;
    
    const request = client.get(url, (response) => {
      if (response.statusCode && (response.statusCode < 200 || response.statusCode >= 300)) {
        reject(new Error(`HTTP ${response.statusCode}: ${response.statusMessage}`));
        return;
      }

      let data = '';
      response.on('data', (chunk) => {
        data += chunk;
      });

      response.on('end', () => {
        resolve(data);
      });
    });

    request.on('error', (error) => {
      reject(new Error(`ÁΩëÁªúËØ∑Ê±ÇÂ§±Ë¥•: ${error.message}`));
    });

    // ËÆæÁΩÆË∂ÖÊó∂
    request.setTimeout(30000, () => {
      request.destroy();
      reject(new Error('ËØ∑Ê±ÇË∂ÖÊó∂ (30s)'));
    });
  });
}

const program = new Command();

program
  .name('ts-sdk-generator')
  .description('Generate TypeScript API clients from OpenAPI specifications using ts-sdk-client')
  .version('1.0.0');

program
  .command('generate')
  .description('Generate API client from OpenAPI spec')
  .option('-i, --input <file>', 'OpenAPI specification file (JSON) or URL (http://|https://)')
  .option('-o, --output <dir>', 'Output directory', './generated')
  .option('-n, --name <name>', 'Generated class name prefix')
  .option('-p, --package <package>', 'ts-sdk-client package name', 'ts-sdk-client')
  .action(async (options) => {
    const { input, output, name, package: packageName } = options;
    
    if (!input) {
      console.error('‚ùå Input file or URL is required. Use -i or --input to specify the OpenAPI file or URL.');
      console.error('   Á§∫‰æã:');
      console.error('   -i ./openapi.json                    # Êú¨Âú∞Êñá‰ª∂');
      console.error('   -i https://api.example.com/openapi   # ÁΩëÁªúÂú∞ÂùÄ');
      process.exit(1);
    }

    try {
      console.log('üöÄ Starting API generation...');
      console.log(`üìÑ Input: ${input}`);
      console.log(`üìÅ Output: ${output}`);
      
      // ËØªÂèñ OpenAPI Êñá‰ª∂ÔºàÊîØÊåÅÊú¨Âú∞Êñá‰ª∂Âíå URLÔºâ
      let specContent: string;
      
      if (isUrl(input)) {
        console.log('üåê ‰ªéÁΩëÁªúÂú∞ÂùÄËé∑Âèñ OpenAPI ËßÑËåÉ...');
        try {
          specContent = await fetchFromUrl(input);
          console.log('‚úÖ ÁΩëÁªúËé∑ÂèñÊàêÂäü');
        } catch (fetchError) {
          const errorMessage = fetchError instanceof Error ? fetchError.message : String(fetchError);
          console.error(`‚ùå ÁΩëÁªúËé∑ÂèñÂ§±Ë¥•: ${errorMessage}`);
          process.exit(1);
        }
      } else {
        console.log('üìÇ ‰ªéÊú¨Âú∞Êñá‰ª∂ËØªÂèñ OpenAPI ËßÑËåÉ...');
        try {
          specContent = fs.readFileSync(input, 'utf-8');
          console.log('‚úÖ Êú¨Âú∞Êñá‰ª∂ËØªÂèñÊàêÂäü');
        } catch (fileError) {
          const errorMessage = fileError instanceof Error ? fileError.message : String(fileError);
          console.error(`‚ùå Êú¨Âú∞Êñá‰ª∂ËØªÂèñÂ§±Ë¥•: ${errorMessage}`);
          process.exit(1);
        }
      }
      
      let spec: OpenAPISpec;
      
      try {
        spec = JSON.parse(specContent);
      } catch (jsonError) {
        console.error('‚ùå JSON Ëß£ÊûêÂ§±Ë¥•„ÄÇÂΩìÂâç‰ªÖÊîØÊåÅ JSON Ê†ºÂºèÔºåYAML ÊîØÊåÅÂç≥Â∞ÜÊé®Âá∫„ÄÇ');
        if (process.env.DEBUG) {
          console.error('Ëß£ÊûêÈîôËØØËØ¶ÊÉÖ:', jsonError);
        }
        process.exit(1);
      }

      // Ëß£Êûê OpenAPI
      console.log('üîç Parsing OpenAPI specification...');
      const parser = new OpenAPIParser();
      const apis = parser.parse(spec);
      console.log(`‚úÖ Found ${apis.length} API group(s)`);

      // Â∞ùËØïËØªÂèñÈ°πÁõÆ package.json Ëé∑ÂèñÈ°πÁõÆÂêçÁß∞
      let projectName = '';
      try {
        // È¶ñÂÖàÂ∞ùËØï‰ªéËæìÂÖ•Êñá‰ª∂Ë∑ØÂæÑÊé®Êñ≠È°πÁõÆÊ†πÁõÆÂΩï
        const inputDir = path.dirname(path.resolve(input));
        const packageJsonPath = path.join(inputDir, 'package.json');
        
        if (fs.existsSync(packageJsonPath)) {
          const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));
          projectName = packageJson.name || '';
          console.log(`üì¶ ‰ªéÈ°πÁõÆ package.json ËØªÂèñÂà∞È°πÁõÆÂêçÁß∞: ${projectName}`);
        } else {
          // Â¶ÇÊûúËæìÂÖ•Êñá‰ª∂ÊâÄÂú®ÁõÆÂΩïÊ≤°Êúâ package.jsonÔºåÂ∞ùËØïÂΩìÂâçÁõÆÂΩï
          const currentPackageJsonPath = path.resolve(process.cwd(), 'package.json');
          if (fs.existsSync(currentPackageJsonPath)) {
            const packageJson = JSON.parse(fs.readFileSync(currentPackageJsonPath, 'utf-8'));
            projectName = packageJson.name || '';
          }
        }
      } catch (error) {
        // ÂøΩÁï•ËØªÂèñÈîôËØØÔºå‰ΩøÁî®ÈªòËÆ§ÂÄº
        console.log('‚ö†Ô∏è  Êó†Ê≥ïËØªÂèñÈ°πÁõÆ package.jsonÔºåÂ∞Ü‰ΩøÁî®ÈªòËÆ§Á±ªÂêç');
      }

      // ÁîüÊàê‰ª£Á†Å
      console.log('üèóÔ∏è  Generating TypeScript code...');
      const generator = new CodeGenerator();
      const files = generator.generate(apis, {
        className: name,
        packageName,
        projectName
      });

      // Ê∏ÖÁêÜÂπ∂ÈáçÊñ∞ÂàõÂª∫ËæìÂá∫ÁõÆÂΩï
      if (fs.existsSync(output)) {
        fs.rmSync(output, { recursive: true, force: true });
        console.log(`üßπ Cleaned existing directory: ${output}`);
      }
      fs.mkdirSync(output, { recursive: true });
      console.log(`üìÅ Created output directory: ${output}`);

      // ÂÜôÂÖ•ÁîüÊàêÁöÑÊñá‰ª∂
      const writtenFiles: string[] = [];
      for (const [fileName, content] of files) {
        const filePath = path.join(output, fileName);
        fs.writeFileSync(filePath, content);
        writtenFiles.push(fileName);
      }

      // ÁîüÊàê tsconfig.json
      const tsconfigPath = path.join(output, 'tsconfig.json');
      const tsconfig = {
        compilerOptions: {
          target: 'ES2020',
          lib: ['ES2020'],
          module: 'CommonJS',
          declaration: true,
          outDir: './dist',
          rootDir: './',
          strict: true,
          esModuleInterop: true,
          skipLibCheck: true,
          forceConsistentCasingInFileNames: true,
          moduleResolution: 'node',
          resolveJsonModule: true,
          allowSyntheticDefaultImports: true,
          sourceMap: false,
          removeComments: false,
          experimentalDecorators: true,
          emitDecoratorMetadata: true
        },
        include: ['*.ts'],
        exclude: ['node_modules', 'dist']
      };
      fs.writeFileSync(tsconfigPath, JSON.stringify(tsconfig, null, 2));
      writtenFiles.push('tsconfig.json');

      // ÁîüÊàê package.jsonÔºàÂ¶ÇÊûú‰∏çÂ≠òÂú®Ôºâ
      const packageJsonPath = path.join(output, 'package.json');
      if (!fs.existsSync(packageJsonPath)) {
      const packageJson: PackageJsonStructure = {
        name: 'generated-api-client',
        version: '1.0.0',
        description: 'Generated API client from OpenAPI specification',
        main: 'dist/index.js',
        types: 'dist/index.d.ts',
        scripts: {
          build: 'tsc',
          clean: 'rm -rf dist',
          prepublishOnly: 'npm run clean && npm run build'
        },
        dependencies: {
          [packageName]: 'file:../../ts-sdk-client',
          'class-transformer': '^0.5.1',
          'class-validator': '^0.14.0',
          'reflect-metadata': '^0.1.13'
        },
        devDependencies: {
          typescript: '^5.0.0'
        }
      };
        
        fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
        console.log(`üì¶ Generated package.json`);
      }

      console.log('‚úÖ API client generated successfully!');
      console.log(`üìù Generated files:`);
      writtenFiles.forEach(file => console.log(`   üìÑ ${file}`));
      console.log(`üìä Total controllers: ${writtenFiles.filter(f => f.endsWith('.api.ts')).length}`);
      console.log('');
      console.log('üéØ Next steps:');
      console.log(`   cd ${output}`);
      console.log('   npm install');
      console.log('   # ‰ΩøÁî®Á§∫‰æã:');
      console.log('   # import { DataApi, UserApi } from "./index";');
      console.log('   # import { withUri, withHeader, withHeaders } from "./types";');
      console.log('   # ');
      console.log('   # const userApi = new UserApi(httpBuilder);');
      console.log('   # const result = await userApi.record(');
      console.log('   #   { data: {...} },');
      console.log('   #   withUri("/custom/path"),');
      console.log('   #   withHeader("X-Request-ID", "unique-id"),');
      console.log('   #   withHeaders({ "X-Custom": "value" })');
      console.log('   # );');
      
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      const errorStack = error instanceof Error ? error.stack : undefined;
      
      console.error('‚ùå Generation failed:', errorMessage);
      if (process.env.DEBUG && errorStack) {
        console.error(errorStack);
      }
      process.exit(1);
    }
  });

program
  .command('validate')
  .description('Validate OpenAPI specification')
  .option('-i, --input <file>', 'OpenAPI specification file or URL')
  .action(async (options) => {
    const { input } = options;
    
    if (!input) {
      console.error('‚ùå Input file or URL is required');
      process.exit(1);
    }

    try {
      console.log(`üîç Validating OpenAPI specification: ${input}`);
      
      // ËØªÂèñ OpenAPI Êñá‰ª∂ÔºàÊîØÊåÅÊú¨Âú∞Êñá‰ª∂Âíå URLÔºâ
      let specContent: string;
      
      if (isUrl(input)) {
        console.log('üåê ‰ªéÁΩëÁªúÂú∞ÂùÄËé∑Âèñ OpenAPI ËßÑËåÉ...');
        try {
          specContent = await fetchFromUrl(input);
          console.log('‚úÖ ÁΩëÁªúËé∑ÂèñÊàêÂäü');
        } catch (fetchError) {
          const errorMessage = fetchError instanceof Error ? fetchError.message : String(fetchError);
          console.error(`‚ùå ÁΩëÁªúËé∑ÂèñÂ§±Ë¥•: ${errorMessage}`);
          process.exit(1);
        }
      } else {
        console.log('üìÇ ‰ªéÊú¨Âú∞Êñá‰ª∂ËØªÂèñ OpenAPI ËßÑËåÉ...');
        try {
          specContent = fs.readFileSync(input, 'utf-8');
          console.log('‚úÖ Êú¨Âú∞Êñá‰ª∂ËØªÂèñÊàêÂäü');
        } catch (fileError) {
          const errorMessage = fileError instanceof Error ? fileError.message : String(fileError);
          console.error(`‚ùå Êú¨Âú∞Êñá‰ª∂ËØªÂèñÂ§±Ë¥•: ${errorMessage}`);
          process.exit(1);
        }
      }
      
      const spec = JSON.parse(specContent);
      
      // Âü∫Êú¨È™åËØÅ
      if (!spec.openapi && !spec.swagger) {
        throw new Error('Not a valid OpenAPI specification');
      }
      
      if (!spec.paths) {
        throw new Error('No paths defined in the specification');
      }
      
      console.log('‚úÖ OpenAPI specification is valid');
      console.log(`üìã Version: ${spec.openapi || spec.swagger}`);
      console.log(`üìÑ Title: ${spec.info?.title || 'Untitled'}`);
      console.log(`üîó Paths: ${Object.keys(spec.paths).length}`);
      
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error('‚ùå Validation failed:', errorMessage);
      process.exit(1);
    }
  });

program.parse();